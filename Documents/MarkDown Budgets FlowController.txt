تحلیل جامع سناریو و گردش کار تأیید فاکتور
این سند به تشریح کامل فرآیند تأیید یک فاکتور از زمان ثبت تا تأیید نهایی یا رد شدن در سیستم شما می‌پردازد. این سیستم بر اساس یک معماری پویا و قانون-محور (Rule-Based) طراحی شده که به آن اجازه می‌دهد گردش‌های کاری پیچیده و چند مرحله‌ای را مدیریت کند.
بخش ۱: مفاهیم و بازیگران کلیدی
برای درک کامل گردش کار، ابتدا باید با مفاهیم اصلی آشنا شویم:
گردش کار (Workflow): مجموعه‌ای از مراحل ترتیبی است که یک فاکتور برای تأیید شدن باید طی کند. این گردش کار به تنخواه متصل است و وضعیت فعلی آن در tankhah.current_stage نگهداری می‌شود.
مرحله (Stage): یک گام مشخص در فرآیند تأیید است (مانند "تأیید مدیر واحد" یا "بررسی مالی"). هر مرحله با یک شماره ترتیب (stage_order) و یک نام (stage) در مدل AccessRule تعریف می‌شود. نکته کلیدی معماری شما این است که stage_order مستقیماً از Post.level (سطح پست سازمانی) گرفته می‌شود.
پست سازمانی (Post): نماینده یک جایگاه در ساختار سازمانی است (مانند "مدیر مالی"). مهم‌ترین ویژگی آن فیلد level است که سلسله مراتب را مشخص می‌کند.
قانون دسترسی (AccessRule): این مدل، مغز متفکر کل سیستم دسترسی و گردش کار است. هر رکورد در این جدول به این سوال پاسخ می‌دهد:
چه کسی (Post)، چه کاری (action_type) را، روی چه چیزی (entity_type)، در چه مرحله‌ای (stage_order) و در کدام سازمان (organization) می‌تواند انجام دهد؟
فرم تأیید ردیف (FactorItemApprovalForm): این فرم، ابزار اصلی کاربر در صفحه تأیید است. این فرم به صورت هوشمند، گزینه‌های "اقدام" را بر اساس allowed_actions که از AccessRule استخراج شده، برای کاربر نمایش می‌دهد.
لاگ تأیید (ApprovalLog): این مدل، حافظه سیستم است. هر اقدامی که هر کاربری روی هر ردیف از فاکتور انجام می‌دهد (تأیید، رد، موقت یا نهایی)، در این جدول ثبت می‌شود. این جدول منبع اصلی حقیقت برای تصمیم‌گیری در مورد پیشرفت گردش کار است.
تابع can_edit_approval: این تابع، نگهبان دروازه است. قبل از اینکه به کاربر اجازه هر اقدامی داده شود، این تابع با بررسی مجموعه‌ای از شرایط (پست فعال، وضعیت قفل بودن، قوانین دسترسی، اقدامات کاربران سطح بالاتر و ...) مشخص می‌کند که آیا کاربر در آن لحظه مشخص، حق اقدام دارد یا خیر.
بخش ۲: سناریوی گام به گام: تأیید یک فاکتور
بیایید سفر یک فاکتور را از ابتدا تا انتها دنبال کنیم. فرض کنید یک "فاکتور خرید تجهیزات کامپیوتری" ثبت شده و باید مراحل تأیید را طی کند.
پرده اول: ورود به صفحه تأیید (درخواست GET)
فراخوانی ویو: یک مدیر (مثلاً "مریم، مدیر واحد IT") روی لینک تأیید فاکتور کلیک می‌کند. درخواست به ویوی FactorItemApproveView ارسال می‌شود.
واکشی داده‌ها: متد get_object اجرا شده و فاکتور به همراه تمام ردیف‌های آن (items) از دیتابیس خوانده می‌شود.
ساخت کانتکست (get_context_data): این متد قلب تپنده ویو است و صفحه را برای کاربر آماده می‌کند:
شناسایی وضعیت فعلی: سیستم factor.tankhah.current_stage را می‌خواند تا بفهمد فاکتور در کدام مرحله از گردش کار قرار دارد (مثلاً مرحله با stage_order=4 به نام "تأیید فنی").
احراز هویت و اختیارات:
سیستم پست فعال مریم (user_post) را پیدا می‌کند.
سپس یک کوئری به جدول AccessRule می‌زند تا ببیند پست مریم در این مرحله (stage_order=4) و برای این سازمان، چه اقداماتی (action_type) را برای FACTORITEM می‌تواند انجام دهد. نتیجه این کوئری لیست allowed_actions خواهد بود (مثلاً ['APPROVE', 'REJECT']).
ساخت رابط کاربری:
یک FactorItemApprovalFormSet ساخته می‌شود. این فرم‌ست برای هر ردیف فاکتور، یک نمونه از FactorItemApprovalForm ایجاد می‌کند.
نکته کلیدی: لیست allowed_actions به هر فرم ارسال می‌شود. فرم در __init__ خود، منوی کشویی "اقدام" را فقط با گزینه‌های مجاز پر می‌کند. اگر allowed_actions خالی باشد، فرم به صورت خودکار غیرفعال می‌شود.
بررسی دسترسی نهایی: متغیر can_edit با فراخوانی تابع can_edit_approval و همچنین بررسی خالی نبودن allowed_actions مقداردهی می‌شود. اگر این متغیر False باشد، تمپلیت تمام دکمه‌ها و فیلدهای فرم را غیرفعال یا مخفی می‌کند.
جمع‌آوری اطلاعات جانبی: ویو اطلاعات تکمیلی زیر را برای نمایش در ستون کناری صفحه آماده می‌کند:
pending_users: چه کسان دیگری در همین مرحله باید اقدام کنند؟
future_approvers_by_stage: پس از این مرحله، فاکتور به دست چه کسانی در چه مراحلی خواهد رسید؟
approval_history: تاریخچه کامل تمام اقدامات قبلی.
رندر صفحه: تمام این اطلاعات به تمپلیت factor_item_approve_final.html ارسال شده و صفحه برای مریم نمایش داده می‌شود. او یک جدول با ردیف‌های فاکتور و فرم‌های اقدام در کنار آن‌ها، و یک ستون کناری با اطلاعات کامل گردش کار را می‌بیند.
پرده دوم: اقدام کاربر (تعامل با فرم)
مریم ردیف‌ها را بررسی می‌کند.
برای ردیف اول، از منوی کشویی گزینه "تأیید" (APPROVE) را انتخاب می‌کند.
برای ردیف دوم، گزینه "رد" (REJECT) را انتخاب کرده و در کادر توضیحات علت را می‌نویسد: "این مدل با مشخصات فنی مورد نیاز همخوانی ندارد."
برای ردیف سوم، تیک "اقدام موقت" (is_temporary) را می‌زند و آن را تأیید می‌کند، چون نیاز به بررسی بیشتر دارد.
در نهایت دکمه "ثبت نهایی اقدامات" را کلیک می‌کند.
پرده سوم: پردازش درخواست (درخواست POST)
درخواست به متد post ویوی FactorItemApproveView ارسال می‌شود.
سیستم مجدداً دسترسی کاربر را با can_edit_approval چک می‌کند.
فرم‌ست با داده‌های ارسالی اعتبارسنجی می‌شود (formset.is_valid()). در این مرحله، متد clean هر فرم اجرا می‌شود. اگر مریم برای ردیف رد شده توضیحات ننوشته بود، فرم در این مرحله خطا می‌داد.
متد _process_formset_actions فراخوانی می‌شود. این متد روی فرم‌های تغییر کرده حلقه می‌زند:
برای هر سه ردیفی که مریم تغییر داده، یک رکورد در جدول ApprovalLog ایجاد یا آپدیت می‌شود که شامل اطلاعات کامل اقدام (کاربر، پست، مرحله، نوع اقدام، کامنت، و موقتی بودن) است.
برای ردیف اول و دوم که اقدام آن‌ها نهایی بود (تیک موقت نداشتند)، فیلد status در خود مدل FactorItem نیز به APPROVE و REJECT تغییر می‌کند.
برای ردیف سوم که موقت بود، status خود آیتم دست‌نخورده باقی می‌ماند.
پرده چهارم: پیشرفت گردش کار (تصمیم‌گیری سیستم)
پس از ثبت موفق اقدامات، متد _check_workflow_advancement فراخوانی می‌شود. این متد مانند یک کارگردان، صحنه بعدی را مشخص می‌کند:
شرط اول: آیا رد نهایی وجود دارد؟
سیستم جدول ApprovalLog را برای این فاکتور و این مرحله جستجو می‌کند. آیا رکوردی با action='REJECT' و is_temporary=False وجود دارد؟
بله. چون مریم ردیف دوم را به صورت نهایی رد کرده، متد _reject_factor فراخوانی می‌شود. کل فاکتور به وضعیت REJECT تغییر کرده، قفل می‌شود و فرآیند در همینجا متوقف می‌شود. یک نوتیفیکیشن برای ایجادکننده فاکتور ارسال می‌شود.
شرط دوم (اگر رد نهایی وجود نداشت): آیا مرحله تکمیل شده است؟
سیستم از AccessRule لیست تمام پست‌های الزامی برای این مرحله (required_post_ids) را استخراج می‌کند.
سپس از ApprovalLog، لیست تمام پست‌هایی که همه ردیف‌ها را به صورت نهایی تأیید کرده‌اند (fully_approved_post_ids) را استخراج می‌کند.
این دو لیست را با هم مقایسه می‌کند: required_post_ids.issubset(fully_approved_post_ids).
دو مسیر ممکن:
اگر شرط برقرار بود (مرحله تکمیل شده): متد _advance_factor_stage فراخوانی می‌شود. این متد به دنبال AccessRule بعدی با stage_order بالاتر می‌گردد.
اگر مرحله بعدی پیدا شد: tankhah.current_stage به مرحله جدید آپدیت می‌شود، وضعیت تمام ردیف‌های فاکتور به PENDING_APPROVAL ریست می‌شود و نوتیفیکیشن برای تأییدکنندگان مرحله بعد ارسال می‌شود.
اگر مرحله بعدی وجود نداشت: این آخرین مرحله بوده است. فاکتور به وضعیت APPROVED_FINAL تغییر کرده، قفل می‌شود و متد _create_payment_order برای صدور دستور پرداخت فراخوانی می‌شود.
اگر شرط برقرار نبود (مرحله تکمیل نشده): هیچ اتفاقی نمی‌افتد. سیستم یک پیغام به مریم نمایش می‌دهد: "اقدام شما ثبت شد. در انتظار تأیید سایر کاربران."
بخش ۳: جمع‌بندی و نقاط قوت
این گردش کار یک سیستم جامع و قدرتمند را به نمایش می‌گذارد که دارای ویژگی‌های زیر است:
پویایی بالا: تمام منطق گردش کار در دیتابیس (مدل AccessRule) تعریف می‌شود و برای تغییر آن نیازی به تغییر کد نیست.
مبتنی بر سلسله مراتب سازمانی: ترتیب مراحل به صورت خودکار از روی سطح پست‌ها (Post.level) تعیین می‌شود.
قابلیت تعریف تأییدکنندگان چندگانه: در هر مرحله می‌توان چندین پست را به عنوان تأییدکننده تعریف کرد.
شفافیت کامل: کاربر در هر لحظه می‌داند چه کسانی قبل از او اقدام کرده‌اند، چه کسانی در کنار او باید اقدام کنند و چه کسانی بعد از او اقدام خواهند کرد.
انعطاف‌پذیری در اقدام: قابلیت اقدام موقت به کاربران اجازه می‌دهد تا فرآیند را متوقف نکنند، حتی اگر نیاز به بررسی بیشتر داشته باشند.
تاریخچه دقیق: تمام اقدامات به همراه جزئیات کامل در ApprovalLog ثبت می‌شوند که قابلیت حسابرسی بالایی را فراهم می‌کند.