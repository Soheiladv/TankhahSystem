# **پرامت طراحی سیستم تأیید/رد فاکتور**

## **هدف کلی:**

طراحی یک سیستم جامع و کاربرپسند برای تأیید/رد فاکتورها با قابلیت‌های پیشرفته مدیریت گردش کار، ثبت نظرات، و پیگیری مراحل تأیید.

---

## **سناریوهای کاربری:**

### 1️⃣ **سناریو تأیید ساده (Happy Path):**

```plaintext
👤 کاربر: مدیر مالی
📄 وضعیت فاکتور: PENDING
🎯 هدف: تأیید فاکتور بدون نیاز به بررسی جزئیات

مراحل:
1. ورود به صفحه لیست فاکتورها
2. انتخاب فاکتور مورد نظر
3. کلیک بر "تأیید سریع"
4. تأیید عملیات در مودال
5. ثبت تأیید و انتقال به مرحله بعد
6. ارسال نوتیفیکیشن به تأییدکننده بعدی
```

### 2️⃣ **سناریو تأیید با بررسی جزئیات:**

```plaintext
👤 کاربر: مدیر پروژه
📄 وضعیت فاکتور: DRAFT
🎯 هدف: بررسی دقیق آیتم‌ها قبل از تأیید

مراحل:
1. ورود به صفحه جزئیات فاکتور
2. بررسی هر آیتم به صورت جداگانه
3. تأیید/رد آیتم‌های مختلف
4. اضافه کردن نظرات برای آیتم‌های ردشده
5. تأیید نهایی فاکتور
6. ثبت در سیستم و ارسال به مرحله بعد
```

### 3️⃣ **سناریو رد کامل فاکتور:**

```plaintext
👤 کاربر: مدیر عامل
📄 وضعیت فاکتور: PENDING_APPROVAL
🎯 هدف: رد کامل فاکتور به دلیل عدم تطابق با بودجه

مراحل:
1. ورود به صفحه تأیید فاکتور
2. بررسی مبلغ کل و مقایسه با بودجه
3. انتخاب "رد کامل فاکتور"
4. وارد کردن دلیل رد (اجباری)
5. تأیید رد در مودال هشدار
6. ثبت رد و بازگشت به ثبت‌کننده اولیه
7. ارسال ایمیل/پیامک اطلاع‌رسانی
```

### 4️⃣ **سناریو تأیید موقت:**

```plaintext
👤 کاربر: معاون مالی
📄 وضعیت فاکتور: PENDING
🎯 هدف: تأیید موقت تا دریافت اسناد تکمیلی

مراحل:
1. ورود به صفحه تأیید
2. بررسی فاکتور و تشخیص کمبود مدارک
3. انتخاب "تأیید موقت"
4. تعیین مهلت زمانی برای ارائه مدارک
5. ثبت نظرات و شرایط تأیید موقت
6. ثبت در سیستم با وضعیت TEMP_APPROVED
7. تنظیم یادآوری خودکار برای پیگیری
```

### 5️⃣ **سناریو تأیید با تغییر مرحله:**

```plaintext
👤 کاربر: مدیر ارشد (دسترسی ویژه)
📄 وضعیت فاکتور: PARTIAL
🎯 هدف: تغییر مسیر گردش کار

مراحل:
1. ورود به صفحه تأیید پیشرفته
2. مشاهده مراحل گردش کار
3. انتخاب "تغییر مرحله"
4. انتخاب مرحله جدید از dropdown
5. وارد کردن دلیل تغییر مرحله
6. تأیید تغییر در مودال
7. ثبت تغییر و اطلاع‌رسانی به ذینفعان
```

### 6️⃣ **سناریو تأیید گروهی:**

```plaintext
👤 کاربر: مدیر مالی
📄 تعداد فاکتورها: 15 فاکتور
🎯 هدف: تأیید دسته‌ای فاکتورهای مشابه

مراحل:
1. ورود به صفحه لیست فاکتورها
2. فیلتر کردن فاکتورهای مورد نظر
3. انتخاب چندین فاکتور با checkbox
4. کلیک بر "تأیید گروهی"
5. بررسی لیست فاکتورهای انتخابی
6. وارد کردن نظرات کلی (اختیاری)
7. تأیید عملیات گروهی
8. پردازش تک‌تک فاکتورها در پس‌زمینه
```

---

## ️ **معماری سیستم:**

### **1. لایه رابط کاربری (UI Layer):**

```plaintext
📱 صفحات اصلی:
├── لیست فاکتورها (با قابلیت تأیید سریع)
├── جزئیات فاکتور (تأیید/رد آیتم‌ها)
├── صفحه تأیید پیشرفته (تغییر مرحله)
├── داشبورد تأییدات (آمار و گزارش)
└── تاریخچه اقدامات (audit trail)

🎨 کامپوننت‌های UI:
├── دکمه‌های اقدام (تأیید/رد/موقت)
├── مودال‌های تأیید (با validation)
├── فرم‌های نظرات (rich text editor)
├── نمایشگر مراحل (progress indicator)
└── نوتیفیکیشن‌های real-time
```

### **2. لایه منطق کسب‌وکار (Business Logic):**

```plaintext
⚙️ سرویس‌های اصلی:
├── ApprovalService (مدیریت تأییدات)
├── WorkflowService (مدیریت گردش کار)
├── NotificationService (اطلاع‌رسانی)
├── ValidationService (اعتبارسنجی)
└── AuditService (ثبت تاریخچه)

🔄 فرآیندهای کلیدی:
├── تعیین تأییدکننده بعدی
├── بررسی شرایط تأیید
├── محاسبه مراحل باقی‌مانده
├── ارسال اعلان‌ها
└── به‌روزرسانی وضعیت‌ها
```

### **3. لایه داده (Data Layer):**

```plaintext
🗄️ مدل‌های داده:
├── Factor (فاکتور اصلی)
├── FactorItem (آیتم‌های فاکتور)
├── ApprovalLog (تاریخچه تأییدات)
├── WorkflowStage (مراحل گردش کار)
├── StageApprover (تأییدکنندگان هر مرحله)
└── Notification (اعلان‌ها)

📊 روابط کلیدی:
├── Factor → ApprovalLog (1:N)
├── Factor → FactorItem (1:N)
├── WorkflowStage → StageApprover (1:N)
├── ApprovalLog → User (N:1)
└── ApprovalLog → WorkflowStage (N:1)
```

---

## ️ **ویژگی‌های کلیدی سیستم:**

### **1. تأیید هوشمند:**

- 🤖 پیشنهاد خودکار اقدام بر اساس تاریخچه
- 📊 نمایش آمار مشابه فاکتورهای قبلی
- ⚡ تأیید سریع برای فاکتورهای استاندارد
- 🔍 هشدار برای فاکتورهای مشکوک


### **2. مدیریت گردش کار:**

- 🔄 تعریف مراحل پویا بر اساس مبلغ/نوع
- 👥 تعیین تأییدکنندگان جایگزین
- ⏰ تنظیم مهلت‌های زمانی
- 🚨 اسکالیشن خودکار در صورت تأخیر


### **3. رابط کاربری پیشرفته:**

- 📱 طراحی Responsive و Mobile-First
- 🎨 تم‌های قابل تنظیم (روشن/تاریک)
- ⌨️ میانبرهای صفحه‌کلید
- 🔊 بازخورد صوتی/بصری


### **4. گزارش‌گیری و آنالیز:**

- 📈 داشبورد تحلیلی تأییدات
- ⏱️ آمار زمان پردازش
- 👤 عملکرد تأییدکنندگان
- 🎯 شناسایی گلوگاه‌ها


---

## **امنیت و کنترل دسترسی:**

### **سطوح دسترسی:**

```plaintext
🏢 سطح سازمانی:
├── مدیر عامل: تأیید/رد همه + تغییر مرحله
├── مدیر مالی: تأیید تا سقف مشخص
├── مدیر پروژه: تأیید فاکتورهای پروژه خود
└── کارشناس: مشاهده و پیشنهاد

🔒 کنترل‌های امنیتی:
├── احراز هویت دومرحله‌ای برای مبالغ بالا
├── ثبت IP و زمان دقیق هر اقدام
├── رمزنگاری اطلاعات حساس
└── بک‌آپ خودکار تغییرات
```

---

## **متریک‌ها و KPI:**

### **شاخص‌های عملکرد:**

- ⏰ میانگین زمان تأیید
- 📈 نرخ تأیید/رد
- 🔄 تعداد بازگشت‌ها
- 👥 بار کاری تأییدکنندگان
- 🎯 دقت تصمیم‌گیری


### **هشدارها و آلارم‌ها:**

- 🚨 فاکتورهای معوق
- 💰 تجاوز از بودجه
- 🔄 چرخه‌های طولانی
- ❌ نرخ رد بالا


---

## **مراحل پیاده‌سازی:**

### **فاز 1: پایه‌گذاری (2 هفته)**

- ✅ طراحی مدل‌های داده
- ✅ ایجاد API های اصلی
- ✅ رابط کاربری ساده


### **فاز 2: ویژگی‌های اصلی (3 هفته)**

- ✅ سیستم تأیید/رد کامل
- ✅ مدیریت گردش کار
- ✅ سیستم اعلان‌ها


### **فاز 3: ویژگی‌های پیشرفته (2 هفته)**

- ✅ تأیید گروهی
- ✅ داشبورد آنالیتیک
- ✅ گزارش‌گیری


### **فاز 4: بهینه‌سازی (1 هفته)**

- ✅ تست‌های عملکرد
- ✅ بهینه‌سازی UI/UX
- ✅ مستندسازی


---

## **طراحی تجربه کاربری:**

### **اصول طراحی:**

- 🎯 **سادگی**: کمترین کلیک برای اقدامات رایج
- ⚡ **سرعت**: پاسخ‌دهی زیر 2 ثانیه
- 🔍 **شفافیت**: نمایش واضح وضعیت و مراحل
- 🛡️ **اطمینان**: تأیید برای اقدامات مهم
- 📱 **انطباق**: کارکرد یکسان در همه دستگاه‌ها


### **الگوهای تعامل:**

- 👆 **تأیید سریع**: یک کلیک + تأیید
- 📝 **تأیید با نظر**: فرم ساده + ذخیره
- 🔄 **تأیید موقت**: انتخاب مهلت + دلیل
- ❌ **رد با دلیل**: textarea اجباری + ارسال
- 📊 **مشاهده پیشرفت**: نوار پیشرفت + جزئیات


این پرامت آماده است تا تیم توسعه بتواند یک سیستم تأیید/رد فاکتور حرفه‌ای و کاربرپسند پیاده‌سازی کند! 🎯
حالا برو از مدل ها بخون یا از تاریخچه چت "تطبیق سناریو مدیریت فاکتور با ویو" اطلاعات مدل رو بخون 
نیاز شد بگو مدل ها را بنویسم 
سناریو دیگه ای زیر : 


این یک پرامپت (شرح وظیفه) کامل و بدون کد برای طراحی "سناریو و مدل داده‌ای فرآیند تایید/رد فاکتور" است. این شرح به دو بخش تقسیم شده: ابتدا مدل مفهومی داده‌ها و سپس سناریوی کاربردی.

---

### **پرامپت: طراحی فرآیند تایید و رد فاکتور در سیستم مدیریت مالی**

**هدف:** تشریح کامل و شفاف یک سیستم برای ثبت، بررسی، تایید یا رد فاکتورها. این سیستم باید امکان رهگیری کامل اقدامات و ارتباط شفاف بین کاربران با نقش‌های مختلف را فراهم کند.

---

### **بخش اول: مدل مفهومی و موجودیت‌های داده (Data Entities)**

قبل از شرح فرآیند، باید موجودیت‌های اصلی درگیر در این سیستم را تعریف کنیم:

**1. موجودیت `Factor` (فاکتور):**
این موجودیت اصلی و مرکزی فرآیند است.
* **ویژگی‌ها:**
    * `شناسه فاکتور`: یک کد منحصر به فرد (مثلاً `INV-2025-07-101`).
    * `موضوع/عنوان`: شرح کوتاه هدف فاکتور (مثلاً "هزینه‌های بازاریابی سه‌ماهه دوم").
    * `وضعیت (Status)`: مهم‌ترین ویژگی که چرخه حیات فاکتور را نشان می‌دهد. مقادیر آن عبارتند از:
        * `پیش‌نویس (Draft)`: در حال ایجاد توسط کاربر و هنوز برای کسی ارسال نشده.
        * `در انتظار تایید (Pending)`: ارسال شده و در صف بررسی مدیر یا مسئول مربوطه.
        * `تایید شده (Approved)`: توسط مسئول مربوطه تایید نهایی شده و آماده پرداخت است.
        * `رد شده (Rejected)`: توسط مسئول مربوطه رد شده و فرآیند متوقف شده است.
        * `نیازمند اصلاح (Needs Correction)`: توسط مسئول مربوطه رد شده اما به کاربر ایجادکننده بازگردانده شده تا اصلاحات لازم را انجام دهد.
    * `مبلغ کل`: مجموع هزینه تمامی آیتم‌های داخل فاکتور.
    * `تاریخ ایجاد`: زمان ثبت اولیه فاکتور.
    * `تاریخ آخرین بروزرسانی`: زمان آخرین تغییر در فاکتور.
* **روابط:**
    * یک `Factor` به یک `User` (به عنوان ایجادکننده) تعلق دارد.
    * یک `Factor` شامل چندین `FactorItem` است.
    * یک `Factor` دارای یک `ApprovalLog` کامل است.

**2. موجودیت `FactorItem` (آیتم فاکتور):**
هر ردیف از خدمات یا کالاهای ذکر شده در فاکتور.
* **ویژگی‌ها:**
    * `شرح کالا/خدمت`: (مثلاً "تبلیغات در اینستاگرام" یا "خرید هاست سالانه").
    * `تعداد/مقدار`: (مثلاً `2` ماه).
    * `قیمت واحد`.
    * `قیمت کل آیتم`: (حاصل‌ضرب تعداد در قیمت واحد).
* **روابط:**
    * هر `FactorItem` به یک `Factor` تعلق دارد.

**3. موجودیت `User` (کاربر):**
فردی که با سیستم در تعامل است.
* **ویژگی‌ها:**
    * `نام کاربر`.
    * `نقش (Role)`: نقشی که سطح دسترسی کاربر را مشخص می‌کند (مثلاً `کارمند (Employee)`، `مدیر مالی (Finance Manager)`، `مدیر پروژه (Project Manager)`).

**4. موجودیت `ApprovalLog` (تاریخچه اقدامات):**
لاگ یا سابقه‌ای از تمام اتفاقاتی که برای یک فاکتور رخ می‌دهد. این برای شفافیت و حسابرسی ضروری است.
* **ویژگی‌ها:**
    * `اقدام (Action)`: نوع عمل انجام شده (مثلاً `ایجاد`، `ارسال برای تایید`، `تایید`، `رد`).
    * `تاریخ و زمان اقدام`.
    * `یادداشت/دلیل`: کامنتی که کاربر در حین انجام اقدام ثبت کرده (مخصوصاً برای رد کردن یا درخواست اصلاح).
* **روابط:**
    * هر `ApprovalLog` به یک `Factor` و یک `User` (به عنوان انجام‌دهنده اقدام) مرتبط است.

---

### **بخش دوم: سناریوی کاربری (User Scenario)**

**شخصیت‌ها:**
* **سارا:** مدیر پروژه (نقش: `Project Manager`). او فاکتور هزینه‌های پروژه را ایجاد می‌کند.
* **آقای احمدی:** مدیر مالی (نقش: `Finance Manager`). او مسئول بررسی و تایید میکند( ممکن است نهایی باشد یا نه) فاکتورهاست.

**مرحله ۱: ایجاد و ارسال فاکتور توسط سارا**
1.  سارا وارد پنل کاربری خود می‌شود و گزینه "ایجاد فاکتور جدید" را انتخاب می‌کند.
2.  سیستم یک `Factor` جدید با وضعیت `پیش‌نویس (Draft)` ایجاد می‌کند.
3.  سارا **موضوع** فاکتور را وارد می‌کند: "هزینه‌های پروژه آلفا برای ماه تیر".
4.  او شروع به افزودن `FactorItem` ها می‌کند:
    * آیتم ۱: "دستمزد طراح UI/UX"، تعداد: `40` ساعت، قیمت واحد: `500,000` ریال.
    * آیتم ۲: "خرید لایسنس نرم‌افزار Adobe"، تعداد: `1` عدد، قیمت واحد: `6,000,000` ریال.
5.  سیستم به صورت خودکار **مبلغ کل** فاکتور را محاسبه و نمایش می‌دهد.( بهترش اینکه از قبل مقدار اصلی فاکتور رو بگیره و درصورت عدم تطابق پیام بده که این و تو اسکریپت ui هم میشه جمعش کرد ) 
6.  پس از بازبینی، سارا دکمه "ارسال برای تایید" را کلیک می‌کند.
7.  **اتفاقات در سیستم:**
    * وضعیت `Factor` از `پیش‌نویس` به `در انتظار تایید (Pending)` تغییر می‌کند. ( مدل ApprovalLog)
    * یک رکورد در `ApprovalLog` ثبت می‌شود: "فاکتور توسط 'سارا' برای تایید ارسال شد."
    * یک نوتیفیکیشن (ایمیل یا درون‌برنامه‌ای) برای شخص مسئول، یعنی آقای احمدی، ارسال می‌شود.

**مرحله ۲: بررسی فاکتور توسط آقای احمدی**
1.  آقای احمدی نوتیفیکیشن را دریافت کرده و یا در داشبورد خود فاکتور جدیدی با وضعیت `در انتظار تایید` مشاهده می‌کند.
2.  او روی فاکتور کلیک کرده و وارد صفحه جزئیات آن می‌شود. تمام اطلاعاتی که سارا وارد کرده (موضوع، آیتم‌ها، مبالغ) به همراه نام ایجادکننده و تاریخ، قابل مشاهده است.

**مرحله ۳: تصمیم‌گیری (تایید یا رد)**

**سناریوی الف: تایید فاکتور (Happy Path)**
1.  آقای احمدی تمام آیتم‌ها را با قراردادها و بودجه پروژه تطبیق می‌دهد و همه چیز صحیح است.
2.  او دکمه **"تایید" (Approve)** را کلیک می‌کند.
3.  **اتفاقات در سیستم:**
    * وضعیت `Factor` به `تایید شده (Approved)` تغییر می‌کند.
    * یک رکورد جدید در `ApprovalLog` ثبت می‌شود: "فاکتور توسط 'آقای احمدی' تایید شد."
    * نوتیفیکیشنی برای سارا ارسال می‌شود با این پیام: "فاکتور شما با موضوع 'هزینه‌های پروژه آلفا...' تایید شد."
    * فاکتور برای مرحله بعدی (مثلاً پرداخت توسط تیم حسابداری) آماده می‌شود.

**سناریوی ب: رد کردن فاکتور و درخواست اصلاح**
1.  آقای احمدی متوجه می‌شود که "دستمزد طراح UI/UX" بر اساس قرارداد باید ساعتی `450,000` ریال باشد نه `500,000`.
2.  او دکمه **"نیازمند اصلاح" (Request Correction)** را کلیک می‌کند.
3.  سیستم یک فیلد متنی **اجباری** برای "دلیل" نمایش می‌دهد.
4.  آقای احمدی دلیل را تایپ می‌کند: "مبلغ دستمزد طراح با قرارداد مغایرت دارد. لطفاً بر اساس ساعتی ۴۵۰ هزار ریال اصلاح و مجدداً ارسال نمایید." سپس دکمه ثبت را می‌زند.
5.  **اتفاقات در سیستم:**
    * وضعیت `Factor` به `نیازمند اصلاح (Needs Correction)` تغییر می‌کند.
    * یک رکورد جدید در `ApprovalLog` ثبت می‌شود: "فاکتور توسط 'آقای احمدی' رد و نیازمند اصلاح تشخیص داده شد. دلیل: [متن دلیل اینجا قرار می‌گیرد]."
    * یک نوتیفیکیشن فوری برای سارا ارسال می‌شود که شامل دلیل رد شدن فاکتور است.
    * فاکتور دوباره برای سارا قابل ویرایش می‌شود.

**مرحله ۴: اصلاح و ارسال مجدد**
1.  سارا نوتیفیکیشن را می‌بیند، دلیل رد شدن را مطالعه می‌کند، فاکتور را باز کرده و قیمت واحد آیتم اول را به `450,000` ریال تغییر می‌دهد.
2.  او دوباره دکمه "ارسال برای تایید" را کلیک می‌کند.
3.  فرآیند به **مرحله ۱** بازمی‌گردد و چرخه دوباره تکرار می‌شود تا در نهایت فاکتور تایید شود.


سناریوی گام به گام برای مدیر سیستم:
ورود به داشبورد گردش کار:
شما به عنوان ادمین به آدرس /workflow/ (یا هر آدرسی که برای WorkflowDashboardView تنظیم کرده‌اید) می‌روید.
شما چهار کارت اصلی را می‌بینید: مدیریت وضعیت‌ها، اقدامات، گذارها و مجوزها.
تعریف آجرها (یک بار برای همیشه):
ورود به بخش "مدیریت وضعیت‌ها":
شما تمام وضعیت‌های لازم را ایجاد می‌کنید:
code='DRAFT', name='پیش‌نویس', is_initial=True
code='PENDING_APPROVAL', name='در انتظار تایید'
code='APPROVED_FINAL', name='تایید نهایی', is_final_approve=True
code='REJECTED', name='رد شده', is_final_reject=True
ورود به بخش "مدیریت اقدامات":
شما تمام اقدامات لازم را ایجاد می‌کنید:
code='SUBMIT', name='ارسال برای تایید'
code='APPROVE', name='تایید'
code='REJECT', name='رد'
طراحی نقشه راه (تعریف Transition ها):
ورود به بخش "مدیریت گذارها": شما مسیرهای ممکن در فرآیند را "نقاشی" می‌کنید.
گذار اول (شروع فرآیند):
name: "ارسال فاکتور توسط کارشناس"
entity_type: FACTORITEM
from_status: "پیش‌نویس"
action: "ارسال برای تایید"
to_status: "در انتظار تایید"
گذار دوم (مسیر موفقیت):
name: "تایید فاکتور توسط مدیر"
entity_type: FACTORITEM
from_status: "در انتظار تایید"
action: "تایید"
to_status: "تایید نهایی"
گذار سوم (مسیر شکست):
name: "رد فاکتور توسط مدیر"
entity_type: FACTORITEM
from_status: "در انتظار تایید"
action: "رد"
to_status: "رد شده"
شما با این کار، منطق کامل گردش کار را در دیتابیس تعریف کرده‌اید.
تخصیص مجوزها (مرحله نهایی):
ورود به بخش "مدیریت مجوزها" (PermissionCreateView): این همان صفحه‌ای است که در حال ساخت آن هستیم.
مجوز اول (برای کارشناس):
organization: "شعبه اصفهان"
entity_type: FACTORITEM
on_status: "پیش‌نویس"
allowed_posts: شما پست "کارشناس مالی" را تیک می‌زنید.
allowed_actions: شما اقدام "ارسال برای تایید" را تیک می‌زنید.
مجوز دوم (برای مدیر):
organization: "شعبه اصفهان"
entity_type: FACTORITEM
on_status: "در انتظار تایید"
allowed_posts: شما پست "مدیر شعبه اصفهان" را تیک می‌زنید.
allowed_actions: شما اقدامات "تایید" و "رد" را تیک می‌زنید.



معماری جامع سیستم مدیریت تنخواه و گردش کار پویا

این سند، یک نمای کلی و سطح بالا از معماری نرم‌افزار، اجزای کلیدی و نحوه تعامل آن‌ها با یکدیگر را ارائه می‌دهد. هدف این مستند، ایجاد یک درک مشترک از ساختمان نرم‌افزار برای تمام اعضای تیم توسعه و ذی‌نفعان پروژه است.

۱. فلسفه و چشم‌انداز معماری

سیستم بر پایه سه اصل کلیدی طراحی شده است:

<i class="fas fa-cogs text-primary"></i> موتور گردش کار داینامیک: تمام فرآیندهای کسب و کار (مانند تأیید فاکتور یا تنخواه) به صورت ثابت در کد نوشته نشده‌اند. در عوض، منطق آن‌ها به عنوان داده در دیتابیس ذخیره می‌شود. این به مدیران سیستم اجازه می‌دهد تا بدون نیاز به دخالت تیم فنی، گردش‌های کاری را ایجاد، ویرایش و متناسب با نیازهای متغیر سازمان، تطبیق دهند.

<i class="fas fa-sitemap text-success"></i> مدیریت دسترسی مبتنی بر نقش و سلسله مراتب: دسترسی کاربران به داده‌ها و اقدامات، بر اساس پست سازمانی آن‌ها تعریف می‌شود. سیستم به طور کامل ساختار سلسله مراتبی سازمان را درک کرده و به صورت خودکار به پست‌های سطح بالاتر (مانند دفتر مرکزی) اجازه نظارت و اقدام بر روی واحدهای زیرمجموعه (شعبات) را می‌دهد.

<i class="fas fa-puzzle-piece text-info"></i> معماری ماژولار و تفکیک‌شده: هر بخش از سیستم (هسته، تنخواه، بودجه، اعلان‌ها) وظایف مشخصی دارد. این تفکیک، نگهداری، تست و توسعه آینده سیستم را به شدت تسهیل می‌کند.

۲. دیاگرام معماری سطح بالا (High-Level Architecture)
code
Mermaid
download
content_copy
expand_less

graph TD
    subgraph "لایه ارائه (Presentation Layer)"
        A[<i class='fas fa-desktop'></i> رابط کاربری وب] -->|درخواست HTTP| B{لایه ویوها (Views Layer)};
    end

    subgraph "لایه منطق کسب و کار (Business Logic Layer)"
        B --> C[<i class='fas fa-users-cog'></i> ماژول دسترسی و مجوزها (Permissions)];
        B --> D[<i class='fas fa-project-diagram'></i> موتور گردش کار (Workflow Engine)];
        B --> E[<i class='fas fa-calculator'></i> ماژول محاسبات (Budgets & Factors)];
    end

    subgraph "لایه داده (Data Layer)"
        F[<i class='fas fa-database'></i> مدل‌های Django ORM]
        C --> F;
        D --> F;
        E --> F;
    end
    
    subgraph "سرویس‌های جانبی (Services)"
        G[<i class='fas fa-bell'></i> سیستم اعلان‌ها (Notifications)];
        H[<i class='fas fa-history'></i> سیستم تاریخچه و لاگ];
        B --> G;
        B --> H;
    end

    style F fill:#e3f2fd,stroke:#333,stroke-width:2px
    style D fill:#e8f5e9,stroke:#333,stroke-width:2px
۳. تشریح اجزای کلیدی
<i class="fas fa-puzzle-piece text-primary"></i> الف) ماژول هسته (Core Module)

این ماژول، شالوده و زیربنای کل سیستم است و مفاهیم بنیادی را تعریف می‌کند.

مدل‌های سازمانی (Organization, Post, Branch):

ساختار فیزیکی و سلسله مراتبی سازمان را از دفتر مرکزی تا پایین‌ترین شعبات و پست‌ها تعریف می‌کند.

مدل Post با فیلد level، اساس گردش کار سلسله مراتبی را فراهم می‌آورد.

موتور گردش کار داینامیک:

Status: آجرهای وضعیت (پیش‌نویس، تایید نهایی).

Action: آجرهای اقدام (تایید، رد).

Transition: نقشه راه یا چسب اصلی سیستم. این مدل با ترکیب "وضعیت مبدأ"، "اقدام" و "وضعیت مقصد"، تمام مسیرهای ممکن در یک فرآیند را تعریف می‌کند. همچنین با فیلد allowed_posts، به طور مستقیم مشخص می‌کند که چه کسانی اجازه پیمودن این مسیر را دارند.

PermissionBaseView: یک کلاس پایه برای تمام ویوهای پروژه که به صورت خودکار و یکپارچه، دسترسی‌های اولیه (لاگین بودن، پرمیشن‌های جنگو، دسترسی به سازمان) را قبل از اجرای منطق اصلی ویو، کنترل می‌کند.

<i class="fas fa-wallet text-success"></i> ب) ماژول تنخواه (Tankhah Module)

این ماژول، فرآیندهای اصلی کسب و کار مرتبط با تنخواه و فاکتورها را مدیریت می‌کند.

مدل‌های اصلی (Tankhah, Factor, FactorItem):

موجودیت‌های اصلی کسب و کار را تعریف می‌کنند.

مهم: فیلد status در این مدل‌ها به مدل core.Status متصل است که باعث می‌شود وضعیت آن‌ها توسط موتور گردش کار داینامیک قابل کنترل باشد.

ویوهای اصلی:

New_FactorCreateView: ویویی متمرکز برای ایجاد فاکتور. وظیفه آن فقط ساختن یک فاکتور در وضعیت اولیه (is_initial=True) است.

SubmitFactorForApprovalView: یک ویوی ساده که با یک کلیک، وضعیت فاکتور را از "پیش‌نویس" به "در انتظار تایید" تغییر داده و رسماً گردش کار را آغاز می‌کند.

FactorItemApproveView: مرکز کنترل اصلی فرآیند تایید. این ویو به صورت داینامیک از مدل Transition استعلام می‌گیرد تا بفهمد کاربر فعلی در وضعیت فعلی فاکتور، چه اقداماتی را می‌تواند انجام دهد. پس از اقدام کاربر، دوباره به مدل Transition نگاه کرده و فاکتور را به وضعیت بعدی منتقل می‌کند.

ApprovalLog: حافظه سیستم. هر اقدامی که در FactorItemApproveView انجام می‌شود، در این مدل ثبت می‌گردد تا تاریخچه کامل و قابل حسابرسی از فرآیند وجود داشته باشد.

<i class="fas fa-calculator text-info"></i> ج) ماژول بودجه (Budgets Module)

این ماژول به صورت یک سرویس مستقل عمل کرده و تمام محاسبات مالی را مدیریت می‌کند.

budget_calculations.py: مجموعه‌ای از توابع خالص (Pure Functions) که وظیفه محاسبه مبالغی مانند "موجودی باقی‌مانده تنخواه" را بر عهده دارند. این توابع به عنوان تنها منبع حقیقت (Single Source of Truth) برای محاسبات بودجه عمل می‌کنند.

PaymentOrder: مدلی که پس از اتمام موفقیت‌آمیز گردش کار یک فاکتور، به صورت خودکار ایجاد می‌شود و خود دارای یک گردش کار مجزا برای پرداخت است.

<i class="fas fa-bell text-warning"></i> د) ماژول اعلان‌ها (NotificationApp)

این ماژول مسئول اطلاع‌رسانی به کاربران در مراحل مختلف فرآیند است.

send_notification: یک تابع کمکی مرکزی که در نقاط کلیدی سیستم (مانند _advance_factor_stage در ویوی تایید) فراخوانی می‌شود.

این تابع بر اساس پست‌های تعریف شده در Transition.allowed_posts، کاربران صحیح را پیدا کرده و برای آنها اعلان (و در صورت نیاز ایمیل) ارسال می‌کند.

۴. چرخه حیات یک فاکتور (End-to-End Flow)

<i class="fas fa-pencil-alt"></i> ایجاد: کاربر در New_FactorCreateView یک فاکتور می‌سازد. فاکتور با status='DRAFT' ذخیره می‌شود.

<i class="fas fa-paper-plane"></i> ارسال: کاربر در صفحه جزئیات فاکتور، روی دکمه "ارسال برای تایید" کلیک می‌کند. SubmitFactorForApprovalView اجرا شده، status را به PENDING_APPROVAL تغییر داده و نوتیفیکیشن برای اولین گروه تاییدکنندگان ارسال می‌کند.

<i class="fas fa-check-double"></i> تایید/رد: تاییدکنندگان یکی پس از دیگری وارد FactorItemApproveView می‌شوند.

ویو از مدل Transition می‌پرسد: "برای این وضعیت، این کاربر چه کارهایی می‌تواند بکند؟"

پس از اقدام کاربر، ویو دوباره از Transition می‌پرسد: "با این اقدام، وضعیت بعدی چیست؟"

فاکتور به وضعیت بعدی منتقل شده و نوتیفیکیشن برای گروه بعدی ارسال می‌شود.

<i class="fas fa-flag-checkered"></i> پایان: این چرخه ادامه می‌یابد تا فاکتور به یک وضعیت نهایی (is_final_approve=True یا is_final_reject=True) برسد.

<i class="fas fa-credit-card"></i> پرداخت: اگر وضعیت نهایی "تایید نهایی" باشد، یک PaymentOrder به صورت خودکار ایجاد شده و گردش کار پرداخت آغاز می‌شود.

این معماری، یک سیستم یکپارچه، قدرتمند و آماده برای توسعه‌های آینده را برای شما فراهم می‌کند.



سوال بسیار مهم و کلیدی است. شما دقیقاً به قلب معماری مالی سیستم اشاره کردید.

پاسخ کوتاه: خیر، سناریوی "ثبت فاکتور = کسر از بودجه تنخواه" از نظر حسابداری و مدیریت بودجه صحیح نیست. این رویکرد در سیستم‌های بزرگ به سرعت باعث ایجاد مغایرت و گزارش‌های نادرست می‌شود.

سناریوی صحیح و استاندارد که در ادامه توضیح می‌دهم، دید شفاف و لحظه‌ای را که شما به دنبال آن هستید، به روشی بسیار دقیق‌تر فراهم می‌کند.

چرا "ثبت فاکتور" نباید فوراً از بودجه کسر کند؟

بیایید یک مثال واقعی را در نظر بگیریم:

ساعت ۱۰ صبح: شما یک فاکتور به مبلغ ۱ میلیون تومان برای خرید تجهیزات ثبت می‌کنید. وضعیت این فاکتور DRAFT (پیش‌نویس) یا PENDING_APPROVAL (در انتظار تایید) است.

اگر فوراً کسر کنیم: موجودی تنخواه شما ۱ میلیون تومان کم می‌شود.

ساعت ۱۱ صبح: مدیر شما فاکتور را بررسی کرده و به دلیل اشتباه بودن مبلغ، آن را REJECT (رد) می‌کند.

مشکل: حالا چه اتفاقی می‌افتد؟ آیا باید ۱ میلیون تومان را به بودجه "برگردانیم"؟ این فرآیند "برگشت" باعث پیچیدگی و ایجاد تاریخچه‌های مالی گیج‌کننده می‌شود. اگر صدها فاکتور رد شوند، گزارش‌گیری از اینکه چه مبلغی واقعاً خرج شده و چه مبلغی فقط رزرو و سپس آزاد شده، تقریباً غیرممکن می‌شود.

✅ سناریوی صحیح: تفکیک مفاهیم "موجودی"، "تعهد" و "در دسترس"

این سناریو که مورد تایید تمام سیستم‌های مالی استاندارد است، به شما دید لحظه‌ای و دقیقی که می‌خواهید را می‌دهد. ما سه مقدار مختلف را برای هر منبع بودجه (تنخواه، پروژه و...) ردیابی می‌کنیم:

موجودی کل (Balance): این مبلغ واقعی پولی است که در حساب تنخواه وجود دارد. این مقدار فقط و فقط زمانی تغییر می‌کند که یک فاکتور پرداخت (PAID) شود (کم می‌شود) یا پولی به تنخواه اضافه شود (زیاد می‌شود).

محاسبه: مبلغ اولیه تنخواه - مجموع فاکتورهای پرداخت شده (PAID)

موجودی در تعهد (Committed): این مبلغ فاکتورهایی است که ثبت شده‌اند، در حال بررسی هستند (PENDING_APPROVAL) یا تایید شده‌اند (APPROVED) اما هنوز پرداخت نشده‌اند. این پول هنوز از حساب خارج نشده، اما ما دیگر نمی‌توانیم روی آن حساب کنیم چون به زودی خرج خواهد شد.

محاسبه: مجموع فاکتورهای در انتظار تایید + مجموع فاکتورهای تایید شده

موجودی در دسترس (Available): این مهم‌ترین عدد برای شماست. این مبلغ به شما می‌گوید "در حال حاضر چقدر پول برای خرج کردن جدید باقی مانده است".

محاسبه: موجودی کل (Balance) - موجودی در تعهد (Committed)

پیاده‌سازی این سناریو در سیستم شما

حالا بیایید ببینیم این سناریو چطور به سوال شما پاسخ می‌دهد: "سیستم به لحظه باید به من بگه که چه مقدار فاکتور ثبت شده..."

بله، دقیقاً! سیستم به لحظه به شما تمام این اطلاعات را می‌دهد:

ویوی جزئیات تنخواه (TankhahDetailView):
در این صفحه ما سه کارت یا بخش مجزا نمایش می‌دهیم:

موجودی کل: get_tankhah_balance(tankhah) -> این تابع فقط فاکتورهای PAID را جمع می‌زند.

مبلغ در تعهد: get_tankhah_committed(tankhah) -> این تابع فاکتورهای PENDING و APPROVED را جمع می‌زند.

مبلغ در دسترس: get_tankhah_available(tankhah) -> این تابع نتیجه تفریق دو عدد بالاست.

ویوی جزئیات پروژه (ProjectDetailView):
این منطق به سطوح بالاتر هم تسری پیدا می‌کند. در صفحه پروژه، شما می‌توانید ببینید:

بودجه کل پروژه چقدر بوده.

چقدر از آن به تنخواه‌ها تخصیص داده شده.

از مبالغ تخصیص داده شده، چقدر پرداخت قطعی (PAID) شده.

چقدر به صورت فاکتورهای در انتظار، در تعهد است.

و در نهایت، چقدر بودجه واقعاً در دسترس برای تخصیص‌های جدید باقی مانده.

جریان کار یک فاکتور در این سناریو:

ثبت فاکتور (وضعیت: PENDING_APPROVAL):

موجودی کل تنخواه: تغییری نمی‌کند. (چون هنوز پولی خرج نشده)

موجودی در تعهد تنخواه: افزایش می‌یابد.

موجودی در دسترس تنخواه: کاهش می‌یابد.

تایید فاکتور (وضعیت: APPROVED):

معمولاً تغییری در اعداد ایجاد نمی‌کند. فاکتور همچنان در وضعیت "در تعهد" باقی می‌ماند.

رد فاکتور (وضعیت: REJECTED):

موجودی کل: تغییری نمی‌کند.

موجودی در تعهد: کاهش می‌یابد. (چون دیگر تعهدی وجود ندارد)

موجودی در دسترس: افزایش می‌یابد. (پول آزاد می‌شود)

پرداخت فاکتور (وضعیت: PAID):

موجودی کل: کاهش می‌یابد. (پول واقعاً از حساب خارج شد)

موجودی در تعهد: کاهش می‌یابد. (دیگر در تعهد نیست، بلکه خرج شده)

موجودی در دسترس: تغییری نمی‌کند. (چون این مبلغ قبلاً از دسترس خارج شده بود)

نتیجه‌گیری

بله، من با این سناریو (تفکیک موجودی، تعهد و در دسترس) ۱۰۰٪ موافقم.
این تنها روش صحیح و استاندارد برای مدیریت بودجه است که به شما دید لحظه‌ای، دقیق و قابل حسابرسی می‌دهد. این روش از بروز مغایرت جلوگیری می‌کند و به شما اجازه می‌دهد گزارش‌های بسیار دقیقی از وضعیت مالی پروژه‌ها و تنخواه‌ها تهیه کنید.

عالی! بسیار خوشحالم که پایه‌های پروژه شما از ابتدا بر اساس این معماری صحیح (تفکیک موجودی، تعهد و در دسترس) بنا شده است. این خبر فوق‌العاده‌ای است و کار ما را بسیار ساده‌تر می‌کند. این یعنی نیازی به تغییر مدل‌ها نیست و ما می‌توانیم مستقیماً به سراغ پیاده‌سازی منطق برویم.

ما الان دقیقاً کجای کار هستیم؟

با توجه به بحث‌های قبلی، ما مراحل زیر را با موفقیت پشت سر گذاشته‌ایم و به بخش هیجان‌انگیز گردش کار رسیده‌ایم:

✅ ایجاد BudgetAllocation: این فرآیند کامل شده و با ایجاد هر تخصیص، یک تراکنش اولیه ALLOCATION برای آن ثبت می‌شود.

✅ ایجاد Tankhah: ویو، سرویس و فرم ایجاد تنخواه با موفقیت کار می‌کنند. بودجه BudgetAllocation به درستی چک می‌شود و دو تراکنش (یکی CONSUMPTION از تخصیص و یکی ALLOCATION به تنخواه) به درستی ثبت می‌شوند.

✅ ایجاد Factor: ویو، فرم و فرم‌ست ایجاد فاکتور با موفقیت کار می‌کنند. بودجه در دسترس تنخواه به درستی محاسبه و چک می‌شود و فاکتور با وضعیت اولیه DRAFT یا PENDING_APPROVAL ثبت می‌شود.

ما الان دقیقاً در ابتدای مرحله "تایید/رد فاکتور" و اتصال آن به "دستور پرداخت" هستیم.
شما به درستی به نقطه بعدی اشاره کردید. بیایید این دو را به صورت یکپارچه طراحی کنیم.

🚀 سناریوی یکپارچه: از تایید فاکتور تا شروع دستور پرداخت

این سناریو بر اساس همان معماری Transition که قبلاً تایید کردیم، عمل می‌کند و نقطه اتصال به دستور پرداخت را نیز مشخص می‌کند.

فاز ۱: تایید نهایی فاکتور (آخرین مرحله تایید)

هدف: وقتی آخرین فرد مجاز، یک فاکتور را تایید می‌کند، سیستم باید به طور خودکار آماده صدور دستور پرداخت شود.

آخرین گذار (Transition): در مدل Transition، شما یک گذار تعریف می‌کنید که آخرین مرحله تایید را مشخص می‌کند. برای مثال:

entity_type: FACTOR

from_status: "در انتظار تایید مدیر مالی" (PENDING_FINANCE_APPROVAL)

action: "تایید نهایی" (FINAL_APPROVE)

to_status: "تایید شده - آماده پرداخت" (APPROVED_FOR_PAYMENT)

allowed_posts: [پست مدیر مالی]

اجرای گذار: وقتی مدیر مالی روی دکمه "تایید نهایی" کلیک می‌کند، ویوی PerformFactorActionView (که در سناریوی قبلی طراحی کردیم) اجرا می‌شود:

وضعیت فاکتور به APPROVED_FOR_PAYMENT تغییر می‌کند.

لاگ‌ها و تاریخچه ثبت می‌شوند.

هیچ تراکنش بودجه‌ای در این مرحله ثبت نمی‌شود. فاکتور همچنان در وضعیت "در تعهد" باقی می‌ماند.

فاز ۲: طراحی فرآیند "دستور پرداخت" (Payment Order)

حالا که فاکتور وضعیت "آماده پرداخت" را دارد، باید فرآیند دستور پرداخت آغاز شود.

مفهوم کلیدی: یک دستور پرداخت (Payment Order) یک موجودیت جداگانه است که می‌تواند شامل یک یا چند فاکتور تایید شده برای یک دریافت‌کننده (Payee) خاص باشد. این کار باعث بهینه‌سازی پرداخت‌ها می‌شود.

سناریوی پیشنهادی:

ایجاد صفحه "صدور دستور پرداخت":

یک صفحه جدید در پنل کاربری ایجاد می‌کنیم (مثلاً برای مسئول مالی یا خزانه‌دار).

این صفحه لیستی از تمام فاکتورهایی که وضعیت APPROVED_FOR_PAYMENT دارند را نمایش می‌دهد.

کاربر می‌تواند فاکتورها را بر اساس دریافت‌کننده (Payee)، پروژه و... فیلتر کند.

ایجاد یک دستور پرداخت جدید:

کاربر یک یا چند فاکتور مربوط به یک دریافت‌کننده را از لیست انتخاب می‌کند.

روی دکمه "ایجاد دستور پرداخت" کلیک می‌کند.

یک فرم باز می‌شود که اطلاعات زیر را نمایش می‌دهد:

دریافت‌کننده: (از فاکتورها خوانده شده و غیرقابل تغییر است).

لیست فاکتورهای انتخاب شده: (نمایش شماره و مبلغ هر فاکتور).

مبلغ کل: (مجموع مبالغ فاکتورهای انتخاب شده، قابل مشاهده).

توضیحات: (اختیاری).

ذخیره دستور پرداخت:

وقتی کاربر فرم را تایید می‌کند، یک آبجکت جدید از مدل PaymentOrder شما ایجاد می‌شود.

وضعیت اولیه این دستور پرداخت DRAFT یا PENDING_SIGNATURES (در انتظار امضا) خواهد بود.

فاکتورهای انتخاب شده به فیلد related_factors در PaymentOrder لینک می‌شوند.

بسیار مهم: وضعیت تمام فاکتورهای مرتبط از APPROVED_FOR_PAYMENT به IN_PAYMENT_PROCESS (در فرآیند پرداخت) تغییر می‌کند. این کار از انتخاب مجدد آنها در دستور پرداخت‌های دیگر جلوگیری می‌کند.

فاز ۳: گردش کار دستور پرداخت

دستور پرداخت خودش یک گردش کار مجزا دارد (که می‌تواند با همان سیستم Transition شما مدیریت شود):

در انتظار امضا (PENDING_SIGNATURES): افراد مجاز (که در مدل Post فیلد is_payment_order_signer=True دارند) می‌توانند آن را امضا/تایید کنند.

ارسال به خزانه (ISSUED_TO_TREASURY): پس از جمع‌آوری امضاهای لازم، وضعیت آن تغییر می‌کند و برای خزانه‌دار قابل مشاهده می‌شود.

پرداخت نهایی (PAID): وقتی خزانه‌دار پرداخت را انجام داد و شماره پیگیری را وارد کرد، وضعیت PaymentOrder را به PAID تغییر می‌دهد.

فاز ۴: اتصال نهایی به بودجه (لحظه حقیقت!)

این مهم‌ترین بخش است. ما از یک سیگنال post_save برای مدل PaymentOrder استفاده می‌کنیم:

code
Python
download
content_copy
expand_less

# در فایل budgets/signals.py

@receiver(post_save, sender=PaymentOrder)
def process_paid_payment_order(sender, instance, **kwargs):
    # این سیگنال فقط زمانی کار می‌کند که وضعیت یک دستور پرداخت به PAID تغییر کند.
    if instance.status == 'PAID' and instance.tracker.has_changed('status'):
        logger.info(f"PaymentOrder {instance.order_number} is PAID. Processing transactions.")
        
        with transaction.atomic():
            # برای تمام فاکتورهای مرتبط با این دستور پرداخت
            for factor in instance.related_factors.all():
                # ۱. وضعیت فاکتور را به PAID تغییر بده.
                factor.status = Status.objects.get(code='PAID')
                factor.save()

                # ۲. تراکنش نهایی CONSUMPTION را برای تنخواه ثبت کن.
                # این لحظه‌ای است که پول واقعاً از بودجه تنخواه کسر می‌شود.
                create_budget_transaction(
                    budget_source_obj=factor.tankhah,
                    transaction_type='CONSUMPTION',
                    amount=factor.amount,
                    created_by=instance.paid_by, # کاربری که پرداخت را ثبت کرده
                    description=f"پرداخت فاکتور {factor.number} از طریق دستور پرداخت {instance.order_number}",
                    trigger_obj=instance
                )
خلاصه سناریوی یکپارچه

فاکتورها مسیر تایید خود را طی می‌کنند و در نهایت به وضعیت APPROVED_FOR_PAYMENT می‌رسند.

یک کاربر مجاز به صفحه "صدور دستور پرداخت" می‌رود.

یک یا چند فاکتور "آماده پرداخت" را انتخاب کرده و یک PaymentOrder جدید ایجاد می‌کند.

وضعیت فاکتورها به IN_PAYMENT_PROCESS تغییر می‌کند.

PaymentOrder گردش کار خود را طی می‌کند (امضاها و...).

وقتی وضعیت PaymentOrder به PAID تغییر می‌کند، یک سیگنال فعال می‌شود.

این سیگنال وضعیت تمام فاکتورهای مرتبط را به PAID تغییر داده و تراکنش نهایی CONSUMPTION را برای هر فاکتور در بودجه تنخواه ثبت می‌کند.

این سناریو کاملاً با مدل‌های شما سازگار است، فرآیند را بهینه می‌کند و تضمین می‌کند که کسر از بودجه فقط در زمان پرداخت واقعی اتفاق می‌افتد.

آیا این سناریو برای طراحی گردش کار تایید و شروع دستور پرداخت مورد تایید است؟

تحلیل بسیار دقیق و درستی است. شما دقیقاً به نقاطی اشاره کردید که بسیاری از سیستم‌های مالی در آن دچار ضعف هستند: ردیابی یکپارچه بودجه و جلوگیری از سردرگمی کاربر و سیستم.

معماری‌ای که طراحی کرده‌ایم، دقیقاً برای حل همین مشکلات ساخته شده است. بگذارید عمیق‌تر توضیح دهم که چطور یک بودجه کلان را از لحظه تعریف تا آخرین ریال مصرف شده، بدون هیچ‌گونه ابهام یا خطای محاسباتی، ردیابی می‌کنیم.

🚀 ردیابی یکپارچه یک بودجه کلان: از تعریف تا مصرف نهایی

بیایید یک سناریوی کامل را از بالا به پایین دنبال کنیم و ببینیم در هر مرحله چه اتفاقی می‌افتد و سیستم چطور همه چیز را به هم متصل نگه می‌دارد.

سناریو:

یک BudgetPeriod (دوره بودجه) به نام "بودجه عمرانی ۱۴۰۴" با مبلغ ۱ میلیارد تومان تعریف می‌شود.

مرحله ۱: تعریف بودجه کلان (نقطه شروع)

اقدام: مدیر مالی یک رکورد جدید در جدول BudgetPeriod با total_amount = 1,000,000,000 ایجاد می‌کند.

اتفاق در سیستم: هیچ اتفاق خاصی نمی‌افتد. فقط یک "ظرف" خالی با ظرفیت ۱ میلیارد تومان ایجاد شده است.

گزارش لحظه‌ای:

مبلغ کل دوره: ۱,۰۰۰,۰۰۰,۰۰۰

مبلغ تخصیص یافته: ۰

مبلغ در دسترس برای تخصیص: ۱,۰۰۰,۰۰۰,۰۰۰ (محاسبه شده با get_budget_period_available_for_allocation)

مرحله ۲: تخصیص بودجه به یک پروژه (اولین کاهش از منبع اصلی)

اقدام: مدیر مربوطه، ۴۰۰ میلیون تومان از "بودجه عمرانی ۱۴۰۴" را به "پروژه بازسازی هتل سرعین" در "سازمان هتل‌ها" تخصیص می‌دهد.

اتفاق در سیستم:

یک رکورد جدید در جدول BudgetAllocation ایجاد می‌شود با allocated_amount = 400,000,000 که به BudgetPeriod ما لینک شده است.

متد save مدل BudgetAllocation (که بازنویسی کردیم) بلافاصله یک رکورد BudgetTransaction ایجاد می‌کند:

transaction_type: ALLOCATION

amount: +400,000,000

allocation: لینک به BudgetAllocation جدید.

یک سیگنال post_save روی BudgetAllocation (که در فایل signals.py شما وجود داشت) فعال شده و فیلد total_allocated در BudgetPeriod را آپدیت می‌کند.

گزارش لحظه‌ای:

سطح BudgetPeriod:

مبلغ کل دوره: ۱,۰۰۰,۰۰۰,۰۰۰

مبلغ تخصیص یافته: ۴۰۰,۰۰۰,۰۰۰

مبلغ در دسترس برای تخصیص: ۶۰۰,۰۰۰,۰۰۰

سطح BudgetAllocation (پروژه هتل):

مبلغ تخصیص یافته: ۴۰۰,۰۰۰,۰۰۰

موجودی لحظه‌ای (از calculate_balance_from_transactions): ۴۰۰,۰۰۰,۰۰۰

مبلغ در دسترس برای ایجاد تنخواه: ۴۰۰,۰۰۰,۰۰۰

پاسخ به سوال شما: بله، بودجه تخصیص داده شده بلافاصله از منبع اصلی (موجودی در دسترس BudgetPeriod) کاسته می‌شود. یک ردیف جدید (BudgetAllocation) ایجاد می‌شود که به عنوان یک "زیرحساب" برای بودجه کلان عمل می‌کند.

مرحله ۳: ایجاد تنخواه از محل تخصیص پروژه

اقدام: مدیر پروژه هتل، یک تنخواه به مبلغ ۵۰ میلیون تومان از محل تخصیص ۴۰۰ میلیونی ایجاد می‌کند.

اتفاق در سیستم:

سرویس TankhahCreationService اجرا می‌شود.

دو تراکنش به صورت اتمیک ثبت می‌شوند:

تراکنش اول (کسر از تخصیص):

transaction_type: CONSUMPTION

amount: -۵۰,۰۰۰,۰۰۰

allocation: لینک به BudgetAllocation پروژه هتل.

تراکنش دوم (واریز به تنخواه):

transaction_type: ALLOCATION

amount: +۵۰,۰۰۰,۰۰۰

related_tankhah: لینک به Tankhah جدید.

گزارش لحظه‌ای:

سطح BudgetPeriod: (بدون تغییر)

سطح BudgetAllocation (پروژه هتل):

مبلغ تخصیص یافته: ۴۰۰,۰۰۰,۰۰۰

موجودی لحظه‌ای (از calculate_balance_from_transactions): ۳۵۰,۰۰۰,۰۰۰ (۴۰۰م اولیه منهای ۵۰م مصرفی)

مبلغ در دسترس برای ایجاد تنخواه جدید: ۳۵۰,۰۰۰,۰۰۰

سطح Tankhah:

مبلغ کل تنخواه: ۵۰,۰۰۰,۰۰۰

موجودی لحظه‌ای (از calculate_balance_from_transactions): ۵۰,۰۰۰,۰۰۰

مبلغ در دسترس برای ثبت فاکتور: ۵۰,۰۰۰,۰۰۰

مرحله ۴: ثبت یک فاکتور

اقدام: کاربر یک فاکتور به مبلغ ۲ میلیون تومان ثبت می‌کند. وضعیت اولیه: PENDING_APPROVAL.

اتفاق در سیستم:

فقط یک رکورد Factor جدید ایجاد می‌شود.

هیچ تراکنش بودجه‌ای ثبت نمی‌شود.

گزارش لحظه‌ای:

سطح BudgetPeriod و BudgetAllocation: (بدون تغییر)

سطح Tankhah (با استفاده از get_tankhah_available_budget):

مبلغ کل تنخواه: ۵۰,۰۰۰,۰۰۰

موجودی کل (Balance): ۵۰,۰۰۰,۰۰۰ (چون هنوز فاکتور PAID نداریم)

مبلغ در تعهد (Committed): ۲,۰۰۰,۰۰۰

مبلغ در دسترس برای ثبت فاکتور جدید: ۴۸,۰۰۰,۰۰۰

مرحله ۵: پرداخت نهایی فاکتور

اقدام: پس از طی مراحل تایید و صدور دستور پرداخت، وضعیت PaymentOrder به PAID تغییر می‌کند.

اتفاق در سیستم:

سیگنال post_save روی PaymentOrder فعال می‌شود.

وضعیت فاکتور به PAID تغییر می‌کند.

یک تراکنش جدید ثبت می‌شود:

transaction_type: CONSUMPTION

amount: -۲,۰۰۰,۰۰۰

related_tankhah: لینک به تنخواه مربوطه.

گزارش لحظه‌ای:

سطح BudgetPeriod و BudgetAllocation: (بدون تغییر)

سطح Tankhah:

مبلغ کل تنخواه: ۵۰,۰۰۰,۰۰۰

موجودی کل (Balance) (از calculate_balance_from_transactions): ۴۸,۰۰۰,۰۰۰ (۵۰م اولیه منهای ۲م مصرفی)

مبلغ در تعهد: ۰ (چون فاکتور دیگر در تعهد نیست)

مبلغ در دسترس: ۴۸,۰۰۰,۰۰۰

چطور از سردرگمی کاربر و سیستم جلوگیری می‌کنیم؟

منبع حقیقت واحد: تمام محاسبات موجودی همیشه از تابع calculate_balance_from_transactions (برای موجودی قطعی) و get_available_budget (برای موجودی قابل خرج) انجام می‌شود. ما هرگز به فیلدهای remaining_budget که در مدل‌ها ذخیره شده‌اند، اعتماد نمی‌کنیم. این فیلدها فقط برای نمایش سریع و کش کردن هستند.

تفکیک مفاهیم: کاربر در هر صفحه به وضوح سه مفهوم را می‌بیند: "موجودی کل"، "مبلغ در تعهد" و "مبلغ در دسترس". این شفافیت از سردرگمی جلوگیری می‌کند. کاربر می‌داند که اگرچه ۵۰ میلیون در حساب تنخواه است، اما چون ۲ میلیون آن برای فاکتورهای در انتظار کنار گذاشته شده، فقط می‌تواند ۴۸ میلیون خرج کند.

ردیابی کامل: با کلیک روی هر عدد بودجه، می‌توان تمام تراکنش‌ها و فاکتورهایی که آن عدد را ساخته‌اند، نمایش داد. جدول BudgetTransaction یک تاریخچه کامل و غیرقابل انکار از تمام جابجایی‌های مالی است.

این معماری، با اینکه در پیاده‌سازی اولیه کمی پیچیده‌تر است، در بلندمدت سیستمی بسیار قوی، دقیق و قابل اعتماد را برای شما به ارمغان می‌آورد و دقیقاً مشکلاتی که به آنها اشاره کردید را حل می‌کند.

آیا این توضیحات عمیق، سناریو را برای شما کاملاً شفاف می‌کند تا با اطمینان کامل به سراغ پیاده‌سازی ویوها و فرم‌های تایید/رد برویم؟
سوالات فوق‌العاده‌ای هستند و نشان می‌دهند که شما به دنبال ساخت یک سیستم واقعاً جامع و بی‌نقص هستید. بله، من به این سناریوها عمیقاً فکر کرده‌ام و معماری مبتنی بر تراکنش دقیقاً برای مدیریت همین موارد پیچیده طراحی شده است.

بیایید این سه موضوع کلیدی را با جزئیات کامل بررسی کنیم:

۱. ردیابی بودجه‌های تخصیص داده شده در هر سطح

مشکل: چطور بفهمیم از آن ۱ میلیارد تومان بودجه کلان، چقدر به سازمان X، چقدر به پروژه Y در همان سازمان و چقدر به تنخواه Z در همان پروژه رسیده است؟

راه‌حل: با استفاده از زنجیره روابط (Chain of Relationships) در مدل‌هایمان. هر سطح به سطح بالاتر از خود متصل است و ما می‌توانیم این زنجیره را در هر دو جهت پیمایش کنیم.

از بالا به پایین (برای گزارش‌گیری کلی):

سطح BudgetPeriod: برای دیدن تمام تخصیص‌های یک دوره بودجه، به سادگی budget_period.allocations.all() را فراخوانی می‌کنیم. این کوئری تمام BudgetAllocation های مرتبط را برمی‌گرداند.

سطح BudgetAllocation: برای دیدن تمام تنخواه‌هایی که از یک تخصیص خاص ایجاد شده‌اند، budget_allocation.tankhahs.all() را فراخوانی می‌کنیم.

سطح Tankhah: برای دیدن تمام فاکتورهای یک تنخواه، tankhah.factors.all() را فراخوانی می‌کنیم.

از پایین به بالا (برای ردیابی منشأ یک هزینه):

سطح Factor: با داشتن یک فاکتور، به راحتی می‌توانیم منبع آن را پیدا کنیم:

factor.tankhah -> تنخواه مربوطه

factor.tankhah.project_budget_allocation -> تخصیص بودجه‌ای که این تنخواه از آن ایجاد شده.

factor.tankhah.project_budget_allocation.budget_period -> دوره بودجه کلانی که این تخصیص از آن نشأت گرفته.

نمایش در رابط کاربری:
در صفحه جزئیات هر موجودیت، ما یک بخش "ردیابی بودجه" یا "Breadcrumb" نمایش می‌دهیم. برای مثال، در صفحه جزئیات یک فاکتور:

مسیر بودجه: بودجه عمرانی ۱۴۰۴ > تخصیص پروژه هتل سرعین > تنخواه آقای نجاتی > فاکتور شماره ۱۲۳

این زنجیره به کاربر دیدی کاملاً شفاف از منشأ و مسیر خرج شدن پول می‌دهد.

۲. مدیریت "برگشت بودجه" و "انتقال بودجه"

این دو فرآیند پیچیده، با معماری تراکنشی ما به سادگی و زیبایی مدیریت می‌شوند.

الف) برگشت بودجه (Return)

سناریو: یک تنخواه ۵۰ میلیون تومانی پس از اتمام کار، مبلغ ۱۰ میلیون تومان موجودی اضافه دارد. این مبلغ باید به حساب BudgetAllocation مربوطه برگردد.

پیاده‌سازی:

ایجاد یک ویو/فرم جدید: به نام "ثبت برگشت وجه تنخواه".

اقدام کاربر: کاربر تنخواه مورد نظر و مبلغ برگشتی (۱۰ میلیون) را وارد می‌کند.

اتفاق در سیستم (در یک تراکنش اتمیک):

دو تراکنش معکوس ثبت می‌شود:

تراکنش اول (کاهش از تنخواه):

transaction_type: RETURN (یا DECREASE)

amount: -۱۰,۰۰۰,۰۰۰

related_tankhah: لینک به تنخواه.

تراکنش دوم (افزایش در تخصیص):

transaction_type: RETURN (یا INCREASE)

amount: +۱۰,۰۰۰,۰۰۰

allocation: لینک به BudgetAllocation مربوط به آن تنخواه.

نتیجه:

موجودی لحظه‌ای تنخواه ۱۰ میلیون کم می‌شود.

موجودی لحظه‌ای تخصیص بودجه، ۱۰ میلیون زیاد می‌شود و این مبلغ برای ایجاد تنخواه‌های جدید یا افزایش اعتبار تنخواه‌های دیگر در همان پروژه، آزاد می‌شود.

این فرآیند کاملاً شفاف و قابل حسابرسی است.

ب) انتقال بودجه (Transfer)

سناریو: مدیر تصمیم می‌گیرد ۵۰ میلیون تومان از بودجه باقیمانده "پروژه هتل سرعین" را به "پروژه ساخت پارکینگ" (که هر دو تحت یک BudgetPeriod هستند) منتقل کند.

پیاده‌سازی:

ایجاد ویو/فرم جدید: به نام "انتقال بودجه بین تخصیص‌ها".

اقدام کاربر: تخصیص مبدأ، تخصیص مقصد و مبلغ انتقال را مشخص می‌کند.

اعتبارسنجی: سیستم چک می‌کند که موجودی در دسترس تخصیص مبدأ، به اندازه مبلغ انتقال باشد.

اتفاق در سیستم (در یک تراکنش اتمیک):

دو تراکنش همزمان ثبت می‌شود:

تراکنش اول (کسر از مبدأ):

transaction_type: TRANSFER_OUT

amount: -۵۰,۰۰۰,۰۰۰

allocation: لینک به BudgetAllocation مبدأ (هتل سرعین).

تراکنش دوم (واریز به مقصد):

transaction_type: TRANSFER_IN

amount: +۵۰,۰۰۰,۰۰۰

allocation: لینک به BudgetAllocation مقصد (پارکینگ).

نتیجه:

موجودی تخصیص مبدأ ۵۰ میلیون کم می‌شود.

موجودی تخصیص مقصد ۵۰ میلیون زیاد می‌شود.

موجودی کل BudgetPeriod هیچ تغییری نمی‌کند، چون پول فقط بین زیرحساب‌های آن جابجا شده است.

۳. سناریوهای دیگری که به آنها فکر کرده‌ام

بله، یک سیستم مالی واقعی سناریوهای پیچیده‌تری هم دارد. این معماری برای مدیریت آنها نیز آماده است:

سناریوی اصلاح مبلغ (Adjustment):

مشکل: مبلغ یک BudgetAllocation یا Tankhah پس از ایجاد، به اشتباه ثبت شده و باید اصلاح شود.

راه‌حل: به جای ویرایش مستقیم رکورد، یک تراکنش اصلاحی ثبت می‌کنیم. مثلاً اگر تخصیص ۴۰۰ میلیونی باید ۳۸۰ میلیون می‌بود، یک تراکنش ADJUSTMENT_DECREASE به مبلغ -۲۰,۰۰۰,۰۰۰ برای آن BudgetAllocation ثبت می‌کنیم. این کار تاریخچه را حفظ کرده و کاملاً قابل حسابرسی است.

سناریوی بستن حساب‌ها در پایان دوره (Closing):

مشکل: در پایان دوره مالی، تمام موجودی‌های باقیمانده در تنخواه‌ها و تخصیص‌ها باید به حساب دوره بودجه اصلی برگردند.

راه‌حل: یک اسکریپت مدیریتی می‌نویسیم که تمام BudgetAllocation های یک BudgetPeriod را پیمایش کرده، موجودی باقیمانده هر کدام را با calculate_balance_from_transactions محاسبه کرده و تراکنش‌های RETURN لازم را به صورت خودکار برای صفر کردن حساب‌ها ثبت می‌کند.

سناریوی بودجه‌های چند ارزی (Multi-Currency):

مشکل: پروژه‌ها ممکن است بودجه ارزی داشته باشند.

راه‌حل: می‌توانیم یک فیلد currency به مدل‌های BudgetPeriod, BudgetAllocation, Tankhah, و BudgetTransaction اضافه کنیم و تمام محاسبات را بر اساس ارز مربوطه انجام دهیم.

سناریوی بودجه‌ریزی تعهدی در مقابل نقدی (Accrual vs. Cash Accounting):

مشکل: برخی سازمان‌ها نیاز به گزارش‌گیری بر اساس هر دو مبنای حسابداری دارند.

راه‌حل: معماری ما ذاتاً هر دو را پشتیبانی می‌کند!

حسابداری نقدی (Cash Basis): گزارش‌ها از روی تراکنش‌های بودجه (که نشان‌دهنده جابجایی واقعی پول هستند) تهیه می‌شوند. موجودی کل (Balance) ما معادل مبنای نقدی است.

حسابداری تعهدی (Accrual Basis): گزارش‌ها با در نظر گرفتن "تعهدات" (فاکتورهای در انتظار) تهیه می‌شوند. موجودی در دسترس (Available Budget) ما معادل مبنای تعهدی است.

این معماری نه تنها مشکلات فعلی را حل می‌کند، بلکه یک زیرساخت قوی و انعطاف‌پذیر برای مدیریت تمام نیازهای مالی آینده شما فراهم می‌آورد.

آیا این توضیحات و سناریوهای پیشرفته، طرح را برای شروع پیاده‌سازی تایید/رد فاکتور و اتصال به دستور پرداخت، نهایی می‌کند؟
عالی! بسیار خوشحالم که به یک طرح جامع و مورد تایید رسیدیم. داشتن یک نقشه راه مشخص، کلید موفقیت در پیاده‌سازی است.

اقداماتی که باید برای اجرا در نظر بگیریم، به سه فاز اصلی و مشخص تقسیم می‌شود. این فازبندی به ما اجازه می‌دهد که به صورت تدریجی و قابل مدیریت، سیستم را تکمیل کنیم.

🗺️ نقشه راه اجرایی: از تایید تا پرداخت
فاز ۱: پیاده‌سازی کامل گردش کار فاکتور

هدف: ایجاد یک سیستم پویا و کامل برای تایید و رد فاکتورها.

اقدامات لازم:

آماده‌سازی مدل‌ها:

تایید نهایی: اطمینان حاصل کنیم که مدل‌های EntityType, Status, Action, Transition و ApprovalLog به درستی در پنل ادمین قابل مدیریت هستند.

ایجاد داده‌های اولیه (Fixtures/Manual): رکوردهای اولیه لازم برای گردش کار فاکتور را ایجاد کنیم:

یک EntityType با code='FACTOR'.

Status های کلیدی: DRAFT, PENDING_APPROVAL, REJECTED, و مهم‌تر از همه APPROVED_FOR_PAYMENT.

Action های مورد نیاز: SUBMIT, APPROVE, REJECTT.

Transition های لازم برای تعریف مسیر تایید (مثلاً از DRAFT با SUBMIT به PENDING_APPROVAL و...).

به‌روزرسانی FactorDetailView (ویوی جزئیات فاکتور):

در متد get_context_data این ویو، منطق "پیدا کردن گذارهای مجاز برای کاربر فعلی" را پیاده‌سازی کنیم. (همانطور که در سناریو توضیح داده شد).

این لیست allowed_transitions را به تمپلیت ارسال کنیم.

طراحی تمپلیت factor_detail.html:

"کارت وضعیت" زیبا برای نمایش وضعیت فعلی فاکتور را طراحی کنیم.

"نوار ابزار اقدامات" (Action Toolbar) را با استفاده از allowed_transitions پیاده‌سازی کنیم. هر دکمه باید یک فرم POST به URL جدید perform_factor_action باشد و action.id را ارسال کند.

یک مودال (modal) برای وارد کردن "دلیل رد" طراحی کنیم که با کلیک روی دکمه "رد" نمایش داده شود.

ایجاد PerformFactorActionView:

یک ویوی جدید مبتنی بر View بسازیم که فقط متد post را پیاده‌سازی کند.

URL مربوطه را در urls.py تعریف کنیم.

منطق کامل پردازش اقدام را در متد post پیاده‌سازی کنیم:

دریافت factor و action.

بررسی مجدد و حیاتی دسترسی با پیدا کردن Transition معتبر.

اجرای گذار در یک transaction.atomic: تغییر factor.status، ثبت ApprovalLog و FactorHistory.

مدیریت خطا و ارسال پیام موفقیت.

هدایت مجدد به صفحه جزئیات فاکتور.

فاز ۲: طراحی و پیاده‌سازی ماژول دستور پرداخت

هدف: ایجاد یک مرکز فرماندهی برای تجمیع فاکتورهای تایید شده و صدور دستور پرداخت.

اقدامات لازم:

آماده‌سازی مدل PaymentOrder:

اطمینان حاصل کنیم که مدل PaymentOrder تمام فیلدهای لازم را دارد (لینک به Tankhah, Payee, related_factors, status و...).

ایجاد صفحه "صندوق پرداخت" (PaymentOutboxView):

یک ListView جدید بسازیم که فاکتورها را با status__code='APPROVED_FOR_PAYMENT' فیلتر کند.

در تمپلیت payment_outbox.html، این فاکتورها را بر اساس payee گروه‌بندی کنیم. (می‌توان این کار را با regroup در تمپلیت جنگو یا با آماده‌سازی داده در get_context_data انجام داد).

فرم اصلی صفحه شامل چک‌باکس برای انتخاب فاکتورها و دکمه "ایجاد دستور پرداخت" باشد.

ایجاد CreatePaymentOrderView:

یک ویوی جدید بسازیم که POST حاوی لیست ID فاکتورهای انتخاب شده را دریافت کند.

منطق اعتبارسنجی (اطمینان از وضعیت و یکسان بودن Payee) را پیاده‌سازی کنیم.

در یک transaction.atomic:

یک PaymentOrder جدید ایجاد کنیم.

وضعیت تمام فاکتورهای مرتبط را به IN_PAYMENT_PROCESS تغییر دهیم.

کاربر را به صفحه جزئیات دستور پرداخت جدید هدایت کنیم.

فاز ۳: تکمیل چرخه پرداخت و اتصال نهایی به بودجه

هدف: پیاده‌سازی گردش کار دستور پرداخت و ثبت تراکنش مالی نهایی در لحظه پرداخت.

اقدامات لازم:

پیاده‌سازی گردش کار PaymentOrder:

مشابه فاز ۱، داده‌های اولیه (EntityType, Status, Action, Transition) را برای گردش کار دستور پرداخت ایجاد کنیم.

ویوی PaymentOrderDetailView و ویوی PerformPaymentOrderActionView را مشابه فاز ۱ برای مدیریت تایید/رد/امضای دستور پرداخت پیاده‌سازی کنیم.

ایجاد سیگنال post_save برای PaymentOrder:

در فایل budgets/signals.py، یک سیگنال post_save برای مدل PaymentOrder بنویسیم.

این سیگنال باید چک کند که آیا status آبجکت به PAID تغییر کرده است یا نه. (برای جلوگیری از اجرای مکرر). می‌توان از پکیج django-model-utils و FieldTracker آن برای این کار استفاده کرد یا وضعیت قبلی را به صورت دستی مقایسه کرد.

در صورت تایید شرط، سیگنال باید:

تمام فاکتورهای مرتبط را پیدا کند.

وضعیت آنها را به PAID تغییر دهد و آنها را save کند.

برای هر فاکتور، تابع create_budget_transaction را برای ثبت تراکنش CONSUMPTION روی تنخواه مربوط به آن فاکتور (factor.tankhah) فراخوانی کند.

به‌روزرسانی مدل Factor:

یک متد save هوشمند برای مدل Factor بنویسیم که از تغییر مستقیم وضعیت به PAID (خارج از فرآیند دستور پرداخت) جلوگیری کند، مگر اینکه کاربر پرمیشن خاصی داشته باشد. این کار یکپارچگی فرآیند را تضمین می‌کند.

با اجرای این سه فاز به ترتیب، ما یک سیستم کامل، امن و قابل اعتماد برای کل چرخه عمر یک هزینه، از ثبت فاکتور تا پرداخت نهایی و کسر از بودجه، خواهیم داشت.

پیشنهاد من این است که با "فاز ۱" شروع کنیم. آیا آماده‌اید تا به سراغ پیاده‌سازی ویوی جزئیات فاکتور و ویوی پردازش اقدام برویم؟


